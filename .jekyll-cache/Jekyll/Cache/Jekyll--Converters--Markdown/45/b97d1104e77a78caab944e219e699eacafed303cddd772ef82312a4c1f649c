I")<h2 id="cpu-스케줄링-chapter-5-cpu-scheduling-part-2">CPU 스케줄링: Chapter 5. CPU Scheduling (Part 2)</h2>

<h2 id="cpu-스케줄링-알고리즘">CPU 스케줄링 알고리즘</h2>

<h3 id="선입-선처리-스케줄링first-come-first-served-scheduling">선입 선처리 스케줄링(First-Come, First-Served Scheduling)</h3>

<p>비선점 스케줄링 방식으로 CPU를 먼제 요청하는 프로세스를 우선적으로 할당하는 방식이다. FIFO 큐를 사용해 쉽게 관리할 수 있다. 가장 간단한 CPU 스케줄링 기법이지만 현재에는 거의 사용되지 않는 스케줄링 기법이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Process</th>
      <th style="text-align: left">Burst time</th>
      <th style="text-align: left">Trunaround time</th>
      <th style="text-align: left">Waiting time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">P1</td>
      <td style="text-align: left">24</td>
      <td style="text-align: left">24</td>
      <td style="text-align: left">0</td>
    </tr>
    <tr>
      <td style="text-align: left">P2</td>
      <td style="text-align: left">3</td>
      <td style="text-align: left">27</td>
      <td style="text-align: left">24</td>
    </tr>
    <tr>
      <td style="text-align: left">P3</td>
      <td style="text-align: left">3</td>
      <td style="text-align: left">30</td>
      <td style="text-align: left">27</td>
    </tr>
  </tbody>
</table>

<p><img src="https://taeho0304.github.io/assets/img/OS/fcfs.PNG" alt="" /></p>

<p>총 대기시간 : ( 0 + 24 + 27 ) = 51
평균 대기시간 : 51 / 3 =17</p>

<p>모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 호위 효과(convoy effect)라고 한다. 이 효과는 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저하되는 결과를 낳는다.</p>

<h3 id="최단-작업-우선-스케줄링-shortest-job-first-scheduling">최단 작업 우선 스케줄링 (Shortest-Job-First Scheduling)</h3>

<p>비선점 스케줄링 방식으로 CPU burst 길이가 짧은 순서대로 할당하는 방식이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Process</th>
      <th style="text-align: left">Burst time</th>
      <th style="text-align: left">Trunaround time</th>
      <th style="text-align: left">Waiting time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">P1</td>
      <td style="text-align: left">6</td>
      <td style="text-align: left">9</td>
      <td style="text-align: left">3</td>
    </tr>
    <tr>
      <td style="text-align: left">P2</td>
      <td style="text-align: left">8</td>
      <td style="text-align: left">24</td>
      <td style="text-align: left">16</td>
    </tr>
    <tr>
      <td style="text-align: left">P3</td>
      <td style="text-align: left">7</td>
      <td style="text-align: left">16</td>
      <td style="text-align: left">9</td>
    </tr>
    <tr>
      <td style="text-align: left">P4</td>
      <td style="text-align: left">3</td>
      <td style="text-align: left">3</td>
      <td style="text-align: left">0</td>
    </tr>
  </tbody>
</table>

<p><img src="https://taeho0304.github.io/assets/img/OS/sjf.PNG" alt="" /></p>

<p>총 대기시간 : ( 3 + 16 + 9 + 0 ) = 28
평균 대기시간 : 28 / 4 =7</p>

<p>최적의 알고리즘이지만 다음 CPU burst 길이를 알 수 있는 방법이 없어 근사적인 값을 활용해 구현한다.(앞서 처리한 프로세스들의 기록을 보고 추측한다.)</p>
:ET